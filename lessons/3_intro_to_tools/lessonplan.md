# Introduction to PEDA and Pwntools

GDB with PEDA and Pwntools are two tools that we will be using extensively
throughout the course. This section is designed to run through their basic use
and to work out any possible kinks that might arise.

Throughout the section we will be using pre-built binaries in the `build`
folder. From the base repository directory, please navigate as follows:

```shell
ubuntu@ubuntu-xenial:/vagrant$ cd lessons/3_intro_to_tools/
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools$ cd build/
```

There should be a couple of binaries already in the directory. They are standard
ELF files that you can run.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools/build$ ./1_sample
Hello, I am a sample program.
```

## PEDA

PEDA (Python Exploit Development Assistance) is an extension to GDB that adds on
a whole bunch of useful commands and quality of life improvements to the
standard GDB experience. The provisioning script should have made the necessary
additions to the GDB configuration so all you need to do to start it is launch
GDB.

Let's walk through an example with the `1_sample` binary.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools/build$ gdb ./1_sample
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./1_sample...(no debugging symbols found)...done.
gdb-peda$ r
Starting program: /vagrant/lessons/3_intro_to_tools/build/1_sample
Hello, I am a sample program.
[Inferior 1 (process 11030) exited normally]
Warning: not running or target is remote
gdb-peda$
```

The prompt should show `gdb-peda`. If it does not, something has gone wrong with
the environment setup. To start off, let's break on main and explore what is
offered by PEDA.

```shell
gdb-peda$ br main
Breakpoint 1 at 0x40052a
gdb-peda$ r
Starting program: /vagrant/lessons/3_intro_to_tools/build/1_sample

 [----------------------------------registers-----------------------------------]
RAX: 0x400526 (<main>:	push   rbp)
RBX: 0x0
RCX: 0x0
RDX: 0x7fffffffe5e8 --> 0x7fffffffe811 ("XDG_SESSION_ID=3")
RSI: 0x7fffffffe5d8 --> 0x7fffffffe7e0 ("/vagrant/lessons/3_intro_to_tools/build/1_sample")
RDI: 0x1
RBP: 0x7fffffffe4f0 --> 0x400540 (<__libc_csu_init>:	push   r15)
RSP: 0x7fffffffe4f0 --> 0x400540 (<__libc_csu_init>:	push   r15)
RIP: 0x40052a (<main+4>:	mov    edi,0x4005c4)
R8 : 0x4005b0 (<__libc_csu_fini>:	repz ret)
R9 : 0x7ffff7de78e0 (<_dl_fini>:	push   rbp)
R10: 0x846
R11: 0x7ffff7a2e740 (<__libc_start_main>:	push   r14)
R12: 0x400430 (<_start>:	xor    ebp,ebp)
R13: 0x7fffffffe5d0 --> 0x1
R14: 0x0
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x400521 <frame_dummy+33>:	jmp    0x4004a0 <register_tm_clones>
   0x400526 <main>:	push   rbp
   0x400527 <main+1>:	mov    rbp,rsp
=> 0x40052a <main+4>:	mov    edi,0x4005c4
   0x40052f <main+9>:	call   0x400400 <puts@plt>
   0x400534 <main+14>:	mov    eax,0x0
   0x400539 <main+19>:	pop    rbp
   0x40053a <main+20>:	ret
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffe4f0 --> 0x400540 (<__libc_csu_init>:	push   r15)
0008| 0x7fffffffe4f8 --> 0x7ffff7a2e830 (<__libc_start_main+240>:	mov    edi,eax)
0016| 0x7fffffffe500 --> 0x0
0024| 0x7fffffffe508 --> 0x7fffffffe5d8 --> 0x7fffffffe7e0 ("/vagrant/lessons/3_intro_to_tools/build/1_sample")
0032| 0x7fffffffe510 --> 0x100000000
0040| 0x7fffffffe518 --> 0x400526 (<main>:	push   rbp)
0048| 0x7fffffffe520 --> 0x0
0056| 0x7fffffffe528 --> 0x3061aa2b46d3584b
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x000000000040052a in main ()
gdb-peda$
```

Notice that the default display is a made lot more informative than with the
vanilla GDB. Other than making it a lot easier to step through programs and view
the changes as they happen, PEDA provides a ton of other functionality as well.
To view the full list of them, you can use the `peda` command.

```shell
gdb-peda$ peda
PEDA - Python Exploit Development Assistance for GDB
For latest update, check peda project page: https://github.com/longld/peda/
List of "peda" subcommands, type the subcommand to invoke it:
aslr -- Show/set ASLR setting of GDB
asmsearch -- Search for ASM instructions in memory
assemble -- On the fly assemble and execute instructions using NASM
checksec -- Check for various security options of binary
cmpmem -- Compare content of a memory region with a file
context -- Display various information of current execution context
context_code -- Display nearby disassembly at $PC of current execution context
context_register -- Display register information of current execution context
context_stack -- Display stack of current execution context
crashdump -- Display crashdump info and save to file
deactive -- Bypass a function by ignoring its execution (eg sleep/alarm)
distance -- Calculate distance between two addresses
dumpargs -- Display arguments passed to a function when stopped at a call instruction
tracecall -- Trace function calls made by the program
... snip ...
traceinst -- Trace specific instructions executed by the program
unptrace -- Disable anti-ptrace detection
utils -- Miscelaneous utilities from utils module
vmmap -- Get virtual mapping address ranges of section(s) in debugged process
waitfor -- Try to attach to new forked process; mimic "attach -waitfor"
xinfo -- Display detail information of address/registers
xormem -- XOR a memory region with a key
xprint -- Extra support to GDB's print command
xrefs -- Search for all call/data access references to a function/variable
xuntil -- Continue execution until an address or function

Type "help" followed by subcommand for full documentation.
gdb-peda$
```

We will go through a few of the interesting commands.

### checksec

The `checksec` command lists the protections that are enabled for the binary.
This is useful when figuring out how to craft your exploit.

```shell
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
gdb-peda$
```

### distance

Often, calculating offsets from addresses is required when crafting your payload
in an exploit. This command makes it easy to find the distance between two
addresses.

```shell
gdb-peda$ distance 0x7fffffffe4f0 0x7fffffffe528
From 0x7fffffffe4f0 to 0x7fffffffe528: 56 bytes, 14 dwords
gdb-peda$
```

### elfsymbol

If you ever needed to get the address for certain symbols in a binary (if you
are lucky and it is not stripped), you can use the `elfsymbol` command.

```shell
gdb-peda$ elfsymbol
Found 2 symbols
puts@plt = 0x400400
__libc_start_main@plt = 0x400410
gdb-peda$
```

### pattern

The pattern generator is one of the features of PEDA I most use. What it does is
generate a [De Brujin
Sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence) of a specified
length. A De Brujin Sequence is a sequence that has unique n-length subsequences
at any of its points. In our case, we are interested in unique 4 length
subsequences since we will be dealing with 32 bit registers. This is especially
useful for finding offsets at which data gets written into registers.

Let's say we create a pattern of length 64.

```shell
gdb-peda$ pattern create 64
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAH'
gdb-peda$
```

Imagine that we have triggered a buffer overflow and find that the instruction
pointer crashes on the address 0x48414132 ('2AAH' in ASCII). We can figure out
the exact offset of our data to place our address to redirect code execution to.

```shell
gdb-peda$ pattern offset 0x48414132
1212236082 found at offset: 60
gdb-peda$ pattern offset 2AAH
2AAH found at offset: 60
gdb-peda$
```

### procinfo

This command parses information from the `/proc/pid/x` directory and presents it
to you.

```shell
gdb-peda$ procinfo
exe = /vagrant/lessons/3_intro_to_tools/build/1_sample
fd[0] -> /dev/pts/0
fd[1] -> /dev/pts/0
fd[2] -> /dev/pts/0
pid = 11038
ppid = 11028
uid = [1000, 1000, 1000, 1000]
gid = [1000, 1000, 1000, 1000]
```

It is particularly useful to view which file descriptors are open.

### vmmap

`vmmap` displays the memory mapping of the process. It is simple to invoke.

```shell
gdb-peda$ vmmap
Start              End                Perm	Name
0x00400000         0x00401000         r-xp	/vagrant/lessons/3_intro_to_tools/build/1_sample
0x00600000         0x00601000         r--p	/vagrant/lessons/3_intro_to_tools/build/1_sample
0x00601000         0x00602000         rw-p	/vagrant/lessons/3_intro_to_tools/build/1_sample
0x00007ffff7a0e000 0x00007ffff7bcd000 r-xp	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 ---p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 r--p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p	mapped
0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7fec000 0x00007ffff7fef000 rw-p	mapped
0x00007ffff7ff6000 0x00007ffff7ff8000 rw-p	mapped
0x00007ffff7ff8000 0x00007ffff7ffa000 r--p	[vvar]
0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp	[vdso]
0x00007ffff7ffc000 0x00007ffff7ffd000 r--p	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffe000 0x00007ffff7fff000 rw-p	mapped
0x00007ffffffde000 0x00007ffffffff000 rw-p	[stack]
0xffffffffff600000 0xffffffffff601000 r-xp	[vsyscall]
gdb-peda$
```

What is important to glean from the listing above is the permissions flags of
each of the segments. Often when developing your exploit, you will need to place
some data somewhere. This data can be arguments to functions expecting a string
pointer or even shellcode. What is required is that the segment that is being
written to is marked writable.

Additionally, if you have a pointer from a memory leak and want to figure out
where exactly the pointer is pointing to, you can drill down specifically on
that address.

```shell
gdb-peda$ vmmap 0x00601000
Start              End                Perm  Name
0x00601000         0x00602000         rw-p
/vagrant/lessons/3_intro_to_tools/build/1_sample
gdb-peda$
```

### find aka searchmem

The `find` command is an alias for the `searchmem` peda command. It searches
memory for a given pattern. It is particularly useful to figure out where data
is or how it flows in a process.

For example, something that is often sought for is the string "/bin/sh". Perhaps
it lays in memory somewhere. We can use `find` to look for it.

```shell
gdb-peda$ find /bin/sh
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0x7ffff7b9a177 --> 0x68732f6e69622f ('/bin/sh')
gdb-peda$
```

## Pwntools

Pwntools is a Python library that provides a framework for writing exploits.
Typically, it is used heavily in CTFs. There are a ton of useful functions
provided by Pwntools but I will briefly describe the process I personally use.

### Using Pwntools

There are three ways you can use Pwntools:

1. Interactively through the python/iPython consoles
2. In a python script
3. Pwntools command line tools

#### Interactively through the Console

Often, you want to try things out before actually writing an actual script when
developing your exploit. The iPython console is a great way to explore the
Pwntools API. For convenience, we will import everything in the `pwn` package to
the global namespace.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools/build$ ipython
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
Type "copyright", "credits" or "license" for more information.

IPython 5.1.0 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: from pwn import *

In [2]:
```

iPython provides tab completion and a built-in system to look up documentation
in docstrings. For example, if we want to look at what the `p32` function does,
we can look it up with the `?` sigil.

```shell
In [4]: p32?
Signature: p32(*a, **kw)
Docstring:
p32(number, sign, endian, ...) -> str

Packs an 32-bit integer

Arguments:
    number (int): Number to convert
    endianness (str): Endianness of the converted integer ("little"/"big")
    sign (str): Signedness of the converted integer ("unsigned"/"signed")
    kwargs (dict): Arguments passed to context.local(), such as
        ``endian`` or ``signed``.

Returns:
    The packed number as a string
File:      /usr/local/lib/python2.7/dist-packages/pwnlib/context/__init__.py
Type:      function

In [5]: p32(0x41424344)
Out[5]: 'DCBA'

In [6]:
```

#### In a Python Script

I like to begin with the following [template] when starting a new exploit.

```python
#!/usr/bin/python

from pwn import *

def main():
    pass

if __name__ == '__main__':
    main()
```

Running the script is as simple as calling python on it. Try running this
[script]:

```python
#!/usr/bin/python

from pwn import *

def main():
    p = process("/bin/sh")
    p.interactive()

if __name__ == '__main__':
    main()
```

Running the script:

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools/scripts$ python 2_shellsample.py
[+] Starting local process '/bin/sh': Done
[*] Switching to interactive mode
$ id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),110(lxd)
$
```

#### Pwntools Command Line Tools

Pwntools installs the `pwn` python script in /usr/local/bin. It provides
frontends to useful features of the library. To get a list of all available
frontends, you can execute `pwn -h`.

```shell
ubuntu@ubuntu-xenial:/vagrant/lessons/3_intro_to_tools/scripts$ pwn -h
usage: pwn [-h]
           {asm,checksec,constgrep,cyclic,disasm,elfdiff,elfpatch,errno,hex,phd,pwnstrip,scramble,shellcraft,unhex,update}
           ...

Pwntools Command-line Interface

positional arguments:
  {asm,checksec,constgrep,cyclic,disasm,elfdiff,elfpatch,errno,hex,phd,pwnstrip,scramble,shellcraft,unhex,update}
    asm                 Assemble shellcode into bytes
    checksec            Check binary security settings
    constgrep           Looking up constants from header files. Example:
                        constgrep -c freebsd -m ^PROT_ '3 + 4'
    cyclic              Cyclic pattern creator/finder
    disasm              Disassemble bytes into text format
    elfdiff             Compare two ELF files
    elfpatch            Patch an ELF file
    errno               Prints out error messages
    hex                 Hex-encodes data provided on the command line or stdin
    phd                 Pwnlib HexDump
    pwnstrip            Strip binaries for CTF usage
    scramble            Shellcode encoder
    shellcraft          Microwave shellcode -- Easy, fast and delicious
    unhex               Decodes hex-encoded data provided on the command line
                        or via stdin.
    update              Check for pwntools updates

optional arguments:
  -h, --help            show this help message and exit
```

You can investigate the available options at your own time. Take a look at the
[documentation] for a more detailed description of each of them.


[template]: ./scripts/1_template.py
[script]: ./scripts/2_shellsample.py
[documentation]: https://docs.pwntools.com/en/stable/commandline.html
